<?xml version="1.0" encoding="UTF-8"?>
<mapping-configuration>
	<!-- 
		order:		   mapping的顺序, 默认为0; 其作用为, 在进行AddOrCover时, 值越小的先执行; 在进行Delete时, 值越大的先执行
		supportCover:  mapping是否支持被覆盖, 默认为true
		supportDelete: mapping是否支持被删除, 默认为true
		extendExpr:    mapping的扩展属性, 可由第三方扩展
	-->
	<property order="0" supportCover="true" supportDelete="true" extendExpr="" />

	<!-- 
		createMode的值包括: none, create, drop_create(可用来重置表), dynamic_update, 默认为create
		
		none模式下, 需要用户自己在数据库创建表, 这里映射文件只是起到一个映射的作用, 所以在此模式下, 无论对该映射执行add或delete操作, 都不会影响到数据库中对应的表
		
		代码逻辑上：
		如果一开始就使用的是dynamic_update模式, 后续可以改成任何模式值, 但是要注意的是, 不要通过drop_create的模式来修改表结构, 只能使用dynamic_update的模式来修改表结构
		如果一开始使用的不是dynamic_update模式, 后续就绝对不要使用dynamic_update模式, 这时就可以使用drop_create的模式来修改表结构
		
		jdb-orm框架配置中全局的tableCreateMode同理
	-->
	<!-- strict的值应为true/false, 默认值为false; 它用来标识是否对本映射的createMode值进行强控制, 如果进行强控制, 则本映射的createMode值可以覆盖全局的tableCreateMode -->
	<!-- 如果strict的值配置了true, 而没有配置createMode, 则使用createMode的默认值create -->
	<table name="SYS_USER" oldName="" class="com.douglei.orm.session.SysUser" createMode="create" strict="false">
		<import-columns path=""/><!-- 从根路径查找, 要导入的列集合, 可以将所有表中的通用字段导入, 具体这个文件中怎么写, 看本文件最下面的注释内容 -->
		<columns>
			<!--
				dbType的值参考《sql映射配置结构设计.smp.xml》中存储过程的dbType的配置
				
				dataType的值包括: string, nstring, char, nchar, number, snumber, datetime, clob, blob, 默认值为string, 或者继承com.douglei.orm.dialect.datatype.mapping.MappingDataType类, 实现自定义的类型, 这里配置自定义类的全路径
				dataType的值必须遵照上面列举的配置值, 框架是区分大小写的
				
				dbType和dataType互斥, dbType的优先级高于dataType; dbType没有默认值, dataType的默认值为string
				dbType通常情况下无法实现跨库, 例如sqlserver和mysql的VARCHAR, 与oracle的VARCHAR2
				
				nullable默认值为true, validate默认值为false; sql参数使用相同逻辑
			-->
			<column name="ID" oldName="IDENTITY" property="id" dbType="VARCHAR" dataType="string" primaryKey="true" length="30" precision="" nullable="true" unique="" defaultValue="" check="" fkTableName="" fkColumnName="" validate="true" />
			<column name="NANE" property="name" dataType="string" length="30" validate="true" unique="true" description="姓名" />
			<column name="AGE" property="age" dataType="number" />
			<column name="SEX" property="sex" dataType="string" />
		</columns>

		<constraints>
			<!-- type = PRIMARY_KEY, UNIQUE, DEFAULT_VALUE(value), CHECK(expression), FOREIGN_KEY(fkTableName, fkColumnName) -->
			<constraint type="" value="" expression="" fkTableName="" fkColumnName="">
				<column name="" /><!-- 注意: 这里配置的是列名, 不配置属性名, 因为是给列加约束 -->
			</constraint>
		</constraints>
		
		<indexes>
			<index name=""><!-- 这个名字配置索引名, 必须配置, 应该与下面createSql和dropSql中索引名一致; 这个地方配置索引名只是在框架中做一个key标识, 与发出的sql语句没有实质关系 -->
				<createSql dialect=""></createSql><!-- dialect标识该语句属于哪种数据库, 如果不配置, 则默认是当前SessionFactory的dialect; 可以配置多个值, 用[,]分割开; 目前可以配置的值包括: oracle, mysql, sqlserver, 不区分大小写 -->
				<dropSql dialect=""></dropSql>
			</index>
		</indexes>
		
		<!-- 对主键的处理器, 如果不配置, 或不配置type均不起作用, type值包括: uuid32, uuid36, sequence, 或自定义的类(实现 {@link PrimaryKeyHandler} 接口), 并在这里配置实现类的全路径 -->
		<primaryKeyHandler type="sequence">
			<!-- 序列, 当上面的类型是sequence时, 该配置才生效 -->
			<!-- name序列名, 如果不指定, 则系统自动生成一个 -->
			<!-- 该序列会在表create时跟着create, 在表drop时跟着drop, 其余时候, 不会有任何处理 -->
			<!-- 主要针对oracle数据库, 可以自定义创建和删除序列的sql语句 -->
			<sequence name="">
				<createSql></createSql><!-- 如果不配置, 则使用系统默认的创建语句 -->
				<dropSql></dropSql><!-- 如果不配置, 则使用系统默认的删除语句 -->
			</sequence>
		</primaryKeyHandler>
		
		<!-- 验证器配置 -->
		<validators>
			<!--
				注意：table或sql, 配置的验证参数, 均只在验证器(com.douglei.orm.sessionfactory.validator.DataValidator)中被使用; 例如验证参数是否必填(nullable=false)等; 
					  直接使用TableSession或SQLSession时, 传入的数据是不会被验证的; 例如给非空字段插入null值等; 所以在实际使用前, 要么通过验证器, 要么自行验证, 传入的数据验证通过后, 再去调用TableSession或SQLSession的方法
			
				配置结构描述: 
				1.name: 参数名, 指定给哪个参数名添加验证器, 如果该参数的validate为false, 又这里配置了验证器, 框架会自动将该参数的validate值改为true; 即想要对一个参数设置验证, 有两种方式, 第一种是将参数的validate值设置为true, 或者在这里配置验证器都可以
				                  如果是列, 则配置name值(即列名, 不是property的值); 如果是sql参数, 则配置sql参数名; 这里要注意大小写和你定义时写的大小写必须一致
				2.验证器名称=验证器配置值, 可以配置多个验证器
				
				目前提供的验证器
				notBlank: 验证指定的参数值是否为空字符串,  若是则验证失败; 其配置任何值都可以, 因为该验证器不会使用配置值, 不过建议配置为true或1
				regex: 正则表达式, 可以配置json数组或json对象
				也可以自己继承 com.douglei.orm.mapping.metadata.validator, 实现自定义的验证器, 并在这里通过: 类的全路径=验证器配置值, 来配置验证器
			 -->
			<validator name="NAME" notBlank="true" regex="{'express':'express是必须配置的, 其他可以选择配置','multiline':'默认false','message':'默认值为: 匹配正则表达式失败','i18nCode':'默认值为: jdb.data.validator.regex.matching.fail'}" />
		</validators>
	</table>
</mapping-configuration>

<!-- 
	--导入列的文件配置内容
	<?xml version="1.0" encoding="UTF-8"?>
	<columns>
		<column name="id" property="id" dataType="number" primaryKey="true" length="10" validate="true" />
		... 与<column>的配置一致
	</columns>
 -->