<?xml version="1.0" encoding="UTF-8"?>
<configuration id="default">
	<environment>
		<!-- <property name="dialect" value="mysql" /> --><!-- value的值包括: mysql, oracle, sqlserver, 如果不配置, 则框架会解析jdbc url, 获取对应的方言 -->
		<!-- <property name="enableStatementCache" value="true" /> --><!-- 是否开启Statement缓存, 即对执行对象缓存, 默认值为true  -->
		<!-- <property name="enableResultCache" value="false" /> --><!-- 是否开启Result缓存, 即对结果集缓存, 默认值为false, 如果需要配置为true, enableStatementCache也要同时配置为true才会生效  -->
		<!-- <property name="enableTableSessionCache" value="true" /> --><!-- 是否开启TableSession缓存, 即对表对象缓存, 默认值为true  -->
		
		<!-- <property name="mappingStore" value="application" /> --><!-- value的值只包括: application, 或在new XmlConfiguration时传入 {@link com.douglei.orm.configuration.environment.mapping.store.MappingStore} 接口的实现类实例 -->
		<!-- <property name="clearMappingStoreOnStart" value="true" /> --><!-- 是否在启动时清空映射存储器, 即清空所有映射数据, 默认值为true -->
		
		<!-- <property name="tableCreateMode" value="none" /> --><!-- value的值包括: none, create, drop_create, dynamic_update, 没有默认值, 可以不配置, 该属性值为全局配置, 如果配置了该属性值, 则所有表映射的createMode属性配置失效(之所以这样设计的原因, 是因为在开发阶段可能对表统一进行dynamic_update的配置, 后期上生产环境可以直接通过全局配置, 直接切换所有表的createMode); 如果需要使用dynamic_update模式, 则enableTableDynamicUpdate必须配置为true, 否则createMode=create -->
		<!-- <property name="enableTableDynamicUpdate" value="false" /> --><!-- 是否开启表的动态更新, 默认值为false, 只有启用了, 框架才会序列化映射信息到serializationFileRootPath路径/文件中  -->
		<!-- <property name="serializationFileRootPath" value="" /> --><!-- 序列化文件的根路径, 配置的路径从磁盘根路径起, 如果不配置则使用操作系统中的用户目录, 即user.home -->
		<!-- <property name="enableColumnDynamicUpdateValidate" value="false" /> --><!-- 是否开启列的动态更新验证[列的动态更新验证含义为, 修改列的数据类型,长度,精度,是否可为空时, 判断是否可以进行修改, 如果不能修改, 则抛出相应的异常信息], 默认值为false  -->
		
		<!-- <property name="dynamicMappingOnceMaxCount" value="10" /> --><!-- 动态映射一次最多操作的数量, 默认值为10 -->
		
		<!-- <property name="enableDataValidate" value="false" /> --><!-- 是否开启数据验证, 即对提交的数据的验证, 默认值为false  -->
		
		<!-- 可以远程操作指定的数据库服务, 进行数据库的create/drop -->
		<remoteDatabase>
			<property name="url" value=""/>
			<property name="username" value=""/>
			<property name="password" value=""/>
			<property name="destroy" value=""/><!-- 在销毁该配置时, 是否也销毁该数据库 -->
			
			<!-- create和drop的顺序是相反的, 例如第一条create语句是create database, 则drop的最后一条语句才是drop database -->
			<createSql>
				<sql></sql>
			</createSql>
			<dropSql>
				<sql></sql>
			</dropSql>
		</remoteDatabase>
		
		<datasource class="com.alibaba.druid.pool.DruidDataSource" closeMethod="">
			<property name="driverClassName" value="${jdbc.driver.class}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		
			<property name="maxActive" value="500" /> 
			<property name="minIdle" value="2" /> 
			<property name="maxWait" value="5000" /> 
			<property name="timeBetweenEvictionRunsMillis" value="60000" /> 
			<property name="poolPreparedStatements" value="true" /> 
			<property name="maxPoolPreparedStatementPerConnectionSize" value="100" />
		</datasource>
		
		<mappings searchAll="false"><!-- 是否扫描所有, 包括扫描所有jar包中的数据, 默认值为false -->
			<mapping path="mappings/sql/sql.smp.xml" />
			<mapping path="mappings/table" />
		</mappings>
	</environment>
	
	<properties placeholderPrefix="${" placeholderSuffix="}">
		<resource path="jdbc.properties" decodeValue="true"/><!-- decodeValue标识是否对配置文件中的数据进行解密, 再使用, 默认值为false  -->
	</properties>
</configuration>